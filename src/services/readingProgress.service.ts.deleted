import { PrismaClient, ReadingProgress, ReadingStatus } from '@prisma/client';
import { CreateReadingProgressDto, UpdateReadingProgressDto } from '../models/readingProgress.types';

/**
 * Service responsible for managing reading progress
 * Follows Single Responsibility Principle
 */
export class ReadingProgressService {
  private prisma: PrismaClient;

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
  }

  /**
   * Create or update reading progress for a book
   */
  async createOrUpdateProgress(
    userId: string, 
    data: CreateReadingProgressDto
  ): Promise<ReadingProgress> {
    // Check if progress already exists
    const existing = await this.prisma.readingProgress.findUnique({
      where: {
        userId_bookId: {
          userId,
          bookId: data.bookId
        }
      }
    });

    if (existing) {
      // Update existing progress
      return this.prisma.readingProgress.update({
        where: {
          id: existing.id
        },
        data: {
          status: data.status,
          currentPage: data.currentPage || existing.currentPage,
          totalPages: data.totalPages || existing.totalPages,
          startDate: data.status === ReadingStatus.READING && !existing.startDate 
            ? new Date() 
            : existing.startDate,
          finishDate: data.status === ReadingStatus.FINISHED 
            ? new Date() 
            : data.status === ReadingStatus.READING 
              ? null 
              : existing.finishDate
        },
        include: {
          book: {
            select: {
              id: true,
              title: true,
              authors: true,
              imageUrl: true,
              pageCount: true
            }
          }
        }
      });
    } else {
      // Create new progress
      return this.prisma.readingProgress.create({
        data: {
          userId,
          bookId: data.bookId,
          status: data.status,
          currentPage: data.currentPage || 0,
          totalPages: data.totalPages,
          startDate: data.status === ReadingStatus.READING ? new Date() : data.startDate,
          finishDate: data.status === ReadingStatus.FINISHED ? new Date() : null
        },
        include: {
          book: {
            select: {
              id: true,
              title: true,
              authors: true,
              imageUrl: true,
              pageCount: true
            }
          }
        }
      });
    }
  }

  /**
   * Get user's reading progress by status
   */
  async getProgressByStatus(
    userId: string, 
    status: ReadingStatus
  ): Promise<ReadingProgress[]> {
    return this.prisma.readingProgress.findMany({
      where: {
        userId,
        status
      },
      include: {
        book: {
          select: {
            id: true,
            title: true,
            authors: true,
            imageUrl: true,
            pageCount: true
          }
        }
      },
      orderBy: {
        updatedAt: 'desc'
      }
    });
  }

  /**
   * Get specific reading progress
   */
  async getProgress(userId: string, bookId: string): Promise<ReadingProgress | null> {
    return this.prisma.readingProgress.findUnique({
      where: {
        userId_bookId: {
          userId,
          bookId
        }
      },
      include: {
        book: {
          select: {
            id: true,
            title: true,
            authors: true,
            imageUrl: true,
            pageCount: true
          }
        }
      }
    });
  }

  /**
   * Update reading progress
   */
  async updateProgress(
    userId: string,
    bookId: string,
    data: UpdateReadingProgressDto
  ): Promise<ReadingProgress | null> {
    const existing = await this.prisma.readingProgress.findUnique({
      where: {
        userId_bookId: {
          userId,
          bookId
        }
      }
    });

    if (!existing) {
      return null;
    }

    const updateData: any = { ...data };

    // Auto-set dates based on status changes
    if (data.status) {
      if (data.status === ReadingStatus.READING && !existing.startDate) {
        updateData.startDate = new Date();
      }
      if (data.status === ReadingStatus.FINISHED) {
        updateData.finishDate = new Date();
      }
      if (data.status === ReadingStatus.WANT_TO_READ || data.status === ReadingStatus.DNF) {
        updateData.finishDate = null;
      }
    }

    return this.prisma.readingProgress.update({
      where: {
        id: existing.id
      },
      data: updateData,
      include: {
        book: {
          select: {
            id: true,
            title: true,
            authors: true,
            imageUrl: true,
            pageCount: true
          }
        }
      }
    });
  }

  /**
   * Delete reading progress
   */
  async deleteProgress(userId: string, bookId: string): Promise<boolean> {
    const existing = await this.prisma.readingProgress.findUnique({
      where: {
        userId_bookId: {
          userId,
          bookId
        }
      }
    });

    if (!existing) {
      return false;
    }

    await this.prisma.readingProgress.delete({
      where: {
        id: existing.id
      }
    });

    return true;
  }

  /**
   * Get reading statistics for user
   */
  async getReadingStats(userId: string) {
    const [wantToRead, reading, finished, dnf] = await Promise.all([
      this.prisma.readingProgress.count({
        where: { userId, status: ReadingStatus.WANT_TO_READ }
      }),
      this.prisma.readingProgress.count({
        where: { userId, status: ReadingStatus.READING }
      }),
      this.prisma.readingProgress.count({
        where: { userId, status: ReadingStatus.FINISHED }
      }),
      this.prisma.readingProgress.count({
        where: { userId, status: ReadingStatus.DNF }
      })
    ]);

    return {
      wantToRead,
      reading,
      finished,
      dnf,
      total: wantToRead + reading + finished + dnf
    };
  }
}